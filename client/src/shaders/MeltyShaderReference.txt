BUFFER A:

// created by florian berger (flockaroo) - 2016
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

// melting wax

// storing history of video in X/Y grid in this texture
// by dividing up the fb into Xnum*Ynum frames
// and render en effect on every frame
// in green-screen regions the effect will be applied continuously
// in other regions it will accumulate only between two concecutive frames of the history

#define Xnum 4
#define Ynum 4

#define N(v) (v.yx*vec2(1,-1))

#define RotNum 5
//#define SUPPORT_EVEN_ROTNUM

#define Res  vec2(textureSize(iChannel0,0))
#define Res1 vec2(textureSize(iChannel1,0))

#define keyTex iChannel3
#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x

const float ang = 2.0*3.1415926535/float(RotNum);
mat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));
mat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));

vec4 getRand(vec2 coord)
{
    return texture(iChannel1,coord.xy/Res1.xy);
}

vec4 randS(vec2 uv)
{
    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);
}

vec4 getCol(vec2 coord)
{
    return texture(iChannel0,coord/Res.xy);
}

float getVal(vec2 coord)
{
    vec4 c = getCol(coord);
	return dot(c.xyz,vec3(.3333));
	return dot(c.xyz,c.xyz);
	return length(getCol(coord));
}

vec2 getGrad(vec2 coord, float eps)
{
    vec2 d = vec2(eps,0);
	return vec2(getVal(coord+d.xy)-getVal(coord-d.xy),
                getVal(coord+d.yx)-getVal(coord-d.yx))/eps;
}

float getRot(vec2 pos, vec2 b)
{
    vec2 p = b;
    float rot=0.0;
    for(int i=0;i<RotNum;i++)
    {
        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));
        p = m*p;
    }
    return rot/float(RotNum)/dot(b,b);
}

void effectFlow(inout vec4 fragColor, vec2 pos)
{
    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x*1.;
    
    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));
    vec2 v=vec2(0);
    float bbMax=0.7*Res.y; bbMax*=bbMax;
    for(int l=0;l<3;l++)
    {
        if ( dot(b,b) > bbMax ) break;
        vec2 p = b;
        for(int i=0;i<RotNum;i++)
        {
#ifdef SUPPORT_EVEN_ROTNUM
            v+=p.yx*getRot(pos+p,-mh*b);
#else
            // this is faster but works only for odd RotNum
            v+=p.yx*getRot(pos+p,b);
#endif
            p = m*p;
        }
        b*=2.0;
    }
    
    fragColor=getCol(pos+v*vec2(-1,1)*4.);
}

void effectSmear(inout vec4 col, vec2 coord)
{
    vec2 g=getGrad(coord,.5);
    col=getCol(coord+g.yx*vec2(1,-1)*.7);
}

void effectDiff(inout vec4 col, vec2 coord)
{
    vec2 g=getGrad(coord,.5);
    col=getCol(coord+g.xy*1.5*iResolution.x/600.);
}

void effect(inout vec4 col, vec2 coord)
{
    vec4 col1,col2,col3;
    effectFlow(col1,coord);   // fluid effect
    effectSmear(col2,coord);  // normal to gradient diffusion effect (smearing out a little)
    effectDiff(col3,coord);   // gradient diffusion effect
    //col2=col;
    //float effType=.2;
    //float effType=.5-.5*sin(iTime*.5);
    float effType=smoothstep(.0,.2,-sin(iTime*.3-.3));
    if(iMouse.y>1.) effType=iMouse.y/iResolution.y;
    col=mix(col1,col3,effType);
    col=mix(col,col2,.3);
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord/iResolution.xy*vec2(Xnum,Ynum);
    
    // uv of next frame i history
    vec2 uv2 = vec2(mod(uv.x-1.+float(Xnum),float(Xnum)),
                    uv.y-(((uv.x-1.)<0.)?1.:0.))/vec2(Xnum,Ynum);
    
    vec4 c1,c2;
    effect(c1,uv2*iResolution.xy);  // effect on history frame
	effect(c2,fragCoord);           // effect on every frame
    
    // copy a new frame on beginning of history (lower left edge)
    if(fragCoord.x<iResolution.x/float(Xnum) && fragCoord.y<iResolution.y/float(Ynum))
    {
	    vec4 col=texture(iChannel2,uv);
    	float bgfact = dot(col.xyz,vec3(-1,2,-1));
        vec4 bg=vec4(1,.95,.75,1);
        bg=texture(iChannel1,fragCoord/iResolution.xy*.2).xyzw*.3+bg*.0;
		c1 = mix(col,bg,bgfact); // some bg color instead of green
		c1.w = bgfact; // store green-ness in .w
    }

    // mix together depending on green-ness
	fragColor=mix(c1,c2,smoothstep(.4,.5,c1.w));
}







BUFFER B: 

// created by florian berger (flockaroo) - 2016
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

// melting wax

// take (interpolate) certain history-frame

#define Xnum 4
#define Ynum 4

float getVal(vec2 uv)
{
    return length(texture(iChannel0,uv).xyz);
}
    
vec2 getGrad(vec2 uv,float delta)
{
    vec2 d=vec2(delta,0);
    return vec2(
        getVal(uv+d.xy)-getVal(uv-d.xy),
        getVal(uv+d.yx)-getVal(uv-d.yx)
    )/delta;
}

vec2 getFrameUV(vec2 uv, float frameDelay)
{
    vec2 uv2 = uv+vec2(mod(frameDelay,float(Xnum)),floor(frameDelay/float(Xnum)));
    uv2/=vec2(Xnum,Ynum);
    return uv2;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
   	vec2 uv = fragCoord.xy / iResolution.xy;
    float strength=clamp(iResolution.x/1900.,0.,.99);
    //float strength=clamp(.7+.3*cos(iTime*.5),0.,.99);
    if(iMouse.x>=2.) strength=iMouse.x/iResolution.x;
    float frameDelay = strength*float(Xnum*Ynum-1);
	fragColor = mix(
        texture(iChannel0,getFrameUV(uv,floor(frameDelay))),
        texture(iChannel0,getFrameUV(uv,ceil(frameDelay))),
                fract(frameDelay)
               );
}


IMAGE:

// created by florian berger (flockaroo) - 2017
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

// melting wax

// mouse left/right - change strength of the effect.
// mouse up/down - change type of effect (up=diffusion, down=fluid)
//
// also see on shaderoo.org [https://www.shaderoo.org/?shader=6BTyk8]
//
// the image is distorted by simple diffusion and/or fluid algorithm 
// (just as in 'spilled' - https://www.shadertoy.com/view/MsGSRd)
// a frame history is built up to be able to fade the strength of the distortion
// (go back in history to a more distorted frame)
// without mouse interaction its always fading modes and strength in time

// apply bumpyness and waxy lighting

float getVal(vec2 uv)
{
    return length(texture(iChannel0,uv).xyz);
}
    
vec2 getGrad(vec2 uv,float delta)
{
    vec2 d=vec2(delta,0);
    return vec2(
        getVal(uv+d.xy)-getVal(uv-d.xy),
        getVal(uv+d.yx)-getVal(uv-d.yx)
    )/delta;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 uv = fragCoord.xy / iResolution.xy;
    vec3 n = vec3(getGrad(uv,2./iResolution.y),150.0);
    //n *= n;
    n=normalize(n);
    fragColor=vec4(n,1);
    vec3 light = normalize(vec3(1,1,2));
    float diff=clamp(dot(n,light),0.5,1.0);
    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);
    spec=pow(spec,20.0);
	fragColor = mix(texture(iChannel0,uv),vec4(1),spec/(diff+spec));
    fragColor.w = 1.;
}

